<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width; initial-scale=1.0">

    <!-- Use title if it's in the page YAML frontmatter -->
    <title>Dokkaa</title>

    <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml">
    <link href="/favicon.png" rel="icon" type="image/png">
    <link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/all.js" type="text/javascript"></script>
    <script type="text/javascript" async="" src="http://www.google-analytics.com/ga.js"></script>
    <script src="/javascripts/modernizr-2.0.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26982762-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body class="products products_dokkaa">
  <header>
    <hgroup>
      <a href="/"><h1 class="title">K2NR.ME</h1></a>
    </hgroup>
  </header>
  <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="http://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="http://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja">Tweet</a>
  <h1 id="dokkaa">Dokkaa</h1>

<p>Dokkaaはマルチホスト・マルチコンテナ環境におけるdockerコンテナクラスタのオーケストレーション、サービスディスカバリ、ヘルスチェック、オートスケーリング等を管理するツールです。</p>

<h2 id="ソースコード">ソースコード</h2>

<p>dokkaaは複数のレポジトリで開発しています。</p>

<ul>
<li><a href="https://github.com/k2nr/dokkaa">dokkaa</a>

<ul>
<li>dokkaaのセントラルレポジトリです。ドキュメントのみでコードはありません。</li>
</ul></li>
<li><a href="https://github.com/k2nr/dokkaa-conductor">dokkaa-conductor</a>

<ul>
<li>後述するconductorのソースコードです。golangで書かれています。</li>
</ul></li>
<li><a href="https://github.com/k2nr/dokkaa-ambassador">dokkaa-ambassador</a>

<ul>
<li>後述するambassadorのソースコードです。golangで書かれています。</li>
</ul></li>
<li><a href="https://github.com/k2nr/dokkaacfg">dokkaacfg</a>

<ul>
<li>dokkaaクラスタ自体の操作を行うためのコマンドラインツールです。rubyで書かれています。</li>
</ul></li>
<li><a href="https://github.com/k2nr/skydns-docker">skydns-docker</a>

<ul>
<li>skydnsのdockerイメージです。</li>
</ul></li>
<li><a href="https://github.com/k2nr/dokkaa-builder">dokkaa-builder</a>

<ul>
<li>将来dokkaaで使う予定のモジュールです。本ドキュメントには出てきません。dokkaaのetcdの操作等を受け持つAPIサービスです。clojureで書かれています。</li>
</ul></li>
</ul>

<h2 id="開発の動機">開発の動機</h2>

<p>dockerをマルチホストで扱うためには(現状dockerだけでは解決できない)多くの課題があります。
Dokkaaの目的はマルチホストでのコンテナクラスタを管理する際に発生する問題を解決して、シンプルにクラスタを管理できるようにすることです。</p>

<p>Dokkaaが解決しようとしている問題は大きく分けて以下の4つです。</p>

<ul>
<li>コンテナのオーケストレーション</li>
<li>コンテナクラスタ内でのサービスディスカバリ</li>
<li>サービスのヘルスチェック</li>
<li>(dockerコンテナの)オートスケーリング</li>
</ul>

<p>この内、サービスディスカバリについては、私のブログで考察しているので、ご一読ください。</p>

<p><a href="http://k2nr.me/blog/2014/08/21/docker-container-management.html">http://k2nr.me/blog/2014/08/21/docker-container-management.html</a></p>

<p>ヘルスチェック、オートスケーリングに関しては現在未実装です。</p>

<h2 id="開発の現状">開発の現状</h2>

<p>dokkaaは現在も私個人で鋭意開発中のプロダクトです。
現段階では未実装のもの、仕様が変わるもの、多数のバグが含まれています。
以下では、現段階で実装できている部分について説明します。</p>

<h2 id="使い方">使い方</h2>

<p>使い方に関しては私のブログにまとめていますので、そちらの「つかいかた」以降をご参照ください。</p>

<p><a href="http://k2nr.me/blog/2014/09/18/dokkaa-the-simplest-docker-cluster-platform-for-microservices.html">http://k2nr.me/blog/2014/09/18/dokkaa-the-simplest-docker-cluster-platform-for-microservices.html</a></p>

<h2 id="技術的な説明">技術的な説明</h2>

<p>上記ブログの操作説明を例に、内部で何が起こっているのかを時系列で解説します。</p>

<h3 id="0-起動時">0. 起動時</h3>

<p>2ホスト起動していると仮定します。
それぞれホストA(10.0.0.1)とホストB(10.0.0.2)と呼びます。
起動時は各ホストでconductor、ambassador、skydnsの3つのdockerコンテナが起動しています。</p>

<p><img src="/products/images/dokkaa.001.png" /></p>

<h3 id="1-etcdへのnginxの登録">1. etcdへのnginxの登録</h3>

<p>ユーザーがetcdに起動したいコンテナ情報をjsonで登録します。
例では、次のようなjsonを</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"image"</span><span class="p">:</span><span class="w"> </span><span class="s2">"dockerfile/nginx"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"scale"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nt">"services"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"nginx"</span><span class="p">:</span><span class="w"> </span><span class="mi">80</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>次のようなコマンドを実行してetcdに登録します。</p>
<pre class="highlight shell"><code><span class="gp">$ </span>curl -L -XPUT -d <span class="nv">value</span><span class="o">=</span><span class="s2">"</span><span class="sb">`</span>cat nginx.json<span class="sb">`</span><span class="s2">"</span> <span class="se">\</span>
    http://&lt;dokkaa IP address&gt;:4001/v2/keys/apps/dummy/nginx/manifest
</code></pre>

<p><img src="/products/images/dokkaa.002.png" /></p>

<h3 id="2-conductorによるnginxコンテナの起動">2. conductorによるnginxコンテナの起動</h3>

<p>etcdにコンテナの情報が追加されたことを検知したconductorはその情報をもとにコンテナを起動します。
具体的には</p>

<ul>
<li><code>dockerfile/nginx</code>を<code>docker pull</code>する</li>
<li>pullしたイメージを起動する</li>
</ul>

<p>上記の処理を行います。以下補足です。</p>

<ul>
<li>nginxはホストAで起動されました。ホストBで起動する可能性もありますが、今回はホストAで起動したと仮定します。</li>
<li>jsonには<code>&quot;services&quot;:{&quot;nginx&quot;:80}</code>となっているため、nginxコンテナの80番ポートをホストAのポートにバインドします。</li>
</ul>

<p><img src="/products/images/dokkaa.003.png" /></p>

<h3 id="3-conductorがnginxサービスのsrvレコードをskydnsに登録">3. conductorがnginxサービスのSRVレコードをskydnsに登録</h3>

<p>nginxコンテナを起動した結果、ホストAにバインドされたnginxコンテナの80番ポートが49785だったと仮定します。(実際にはホストの空いているポートにランダムにバインドされます)</p>

<p>nginxのjsonに記述されているnginxサービス(nginxコンテナの80番ポート)はホストA(<code>10.0.0.1</code>)の49785ポートなので、skydnsに次のSRVレコードを登録します。</p>

<ul>
<li><code>nginx.dummy.skydns.local</code> → <code>10.0.0.1:49785</code></li>
</ul>

<p>見ての通りですが、ドメイン名のルールは<code>&lt;サービス名&gt;.&lt;app名&gt;.skydns.local</code>です。</p>

<p><img src="/products/images/dokkaa.004.png" /></p>

<h3 id="4-etcdへのcrawlerの登録">4. etcdへのcrawlerの登録</h3>

<p>nginxコンテナと同じようにして、crawlerをjson形式でetcdに追加します。</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"image"</span><span class="p">:</span><span class="w"> </span><span class="s2">"dockerfile/ubuntu"</span><span class="p">,</span><span class="w">
  </span><span class="nt">"scale"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nt">"command"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="s2">"/bin/bash"</span><span class="p">,</span><span class="w">
      </span><span class="s2">"-c"</span><span class="p">,</span><span class="w">
      </span><span class="s2">"while true; do curl http://$SERVICE_NGINX_ADDR:$SERVICE_NGINX_PORT; sleep 2; done"</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nt">"links"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="s2">"nginx"</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
<pre class="highlight shell"><code><span class="gp">$ </span>curl -L -XPUT --data-urlencode <span class="nv">value</span><span class="o">=</span><span class="s2">"</span><span class="sb">`</span>cat crawler.json<span class="sb">`</span><span class="s2">"</span> <span class="se">\</span>
    http://&lt;dokkaa IP address&gt;:4001/v2/keys/apps/dummy/crawler/manifest
</code></pre>

<p><img src="/products/images/dokkaa.005.png" /></p>

<h3 id="5-conductorによるcrawlerの起動">5. conductorによるcrawlerの起動</h3>

<p>conductorがコンテナを起動します。
このとき、conductorはホストBで起動します。
dokkaaは各ホストで起動しているコンテナの数が同じになるように、コンテナをどのホストで起動するか制御しているためです。
またこの時、conductorはコンテナに以下の環境変数をセットします。</p>

<ul>
<li><code>SERVICE_NGINX_ADDR=ambassador</code></li>
<li><code>SERVICE_NGINX_PORT=10001</code></li>
<li><code>BACKENDS_10001=nginx.dummy.skydns.local</code></li>
</ul>

<p>crawlerのjsonにはサービスの指定はないのでskydnsへのドメイン登録は行いません。</p>

<p><img src="/products/images/dokkaa.006.png" /></p>

<h3 id="6-crawlerからcurlを実行">6. crawlerからcurlを実行</h3>

<p>crawlerは延々<code>curl http://$SERVICE_NGINX_ADDR:$SERVICE_NGINX_PORT</code>を実行し続けるコンテナです。
curlの宛先は<code>http://ambassador:10001</code>なので、crawlerと同一ホスト(ホストB)のambassadorがまずリクエストを受けます。</p>

<p><img src="/products/images/dokkaa.007.png" /></p>

<h3 id="7-ambassadorがcrawlerコンテナの環境変数を確認">7. ambassadorがcrawlerコンテナの環境変数を確認</h3>

<p>リクエストを受けたambassadorはdocker remote APIを通じてcrawlerの環境変数<code>$BACKENDS_10001</code>の値を確認します。</p>

<p><img src="/products/images/dokkaa.008.png" /></p>

<h3 id="8-ambassadorがskydnsにドメイン確認">8. ambassadorがskydnsにドメイン確認</h3>

<p><code>$BACKENDS_10001</code>はconductorによって<code>nginx.dummy.skydns.local</code>に設定されているので、ambassadorは<code>nginx.dummy.skydns.local</code>を名前解決するため、skydnsにこのドメインのSRVレコードの解決を要求します。
すると、skydnsは<code>nginx.dummy.skydns.local</code>を<code>10.0.0.1:49785</code>に解決します。</p>

<p><img src="/products/images/dokkaa.009.png" /></p>

<h3 id="9-ambassadorが通信をnginxコンテナにプロキシ">9. ambassadorが通信をnginxコンテナにプロキシ</h3>

<p>nginxサービスが<code>10.0.0.1:49785</code>で動いてることがわかったので、ambassadorはcrawlerからのリクエストを<code>10.0.0.1:49785</code>に転送します</p>

<p><img src="/products/images/dokkaa.010.png" /></p>

<h2 id="まとめ">まとめ</h2>

<p>まだまだ未完成のプロジェクトですが、将来的にはdokkaaを使用することで、マルチホストに渡るdockerクラスタの構築を簡単に実現できるようになることを目指しています。上で挙げた、Dokkaaが解決しようとしている問題を再掲します。</p>

<ul>
<li>コンテナのオーケストレーション</li>
<li>コンテナクラスタ内でのサービスディスカバリ</li>
<li>サービスのヘルスチェック</li>
<li>オートスケーリング</li>
</ul>

<p>これらの課題を、dokkaaユーザーは</p>

<ol>
<li>jsonを記述して</li>
<li>dokkaaのコマンドを一つ実行する</li>
</ol>

<p>だけで解決できるようになることが目的です。</p>

<h2 id="今後の課題">今後の課題</h2>

<ul>
<li>ヘルスチェックの実装</li>
<li>オートスケーリングの実装</li>
<li>コンテナ内にファイルを保存するようなコンテナの扱い

<ul>
<li>基本的にdokkaaはコンテナを使い捨てることを前提としており、突然コンテナがシャットダウンされることやコンテナが動作するホストを変える(例えばホストAからホストBに移る)ことも(将来的には)ありえますが、コンテナが内部にファイルを保存する場合、ホストを移動してしまったり、あるいはコンテナがオートスケールしてしまうとまともに動作しません。こういった場合にコンテナが使用していたヴォリュームをどのように扱うのか未検討です。</li>
</ul></li>
<li>webロールの実装

<ul>
<li>サービスに対して、<code>web</code>というロールを設定できるようにすることを検討しています。例えば、上記の<code>nginx</code>サービスがwebロールを持っていて、dokkaa自体に<code>dokkaa.io</code>のようなドメインを与えていた場合、<code>nginx.dummy.dokkaa.io</code>というドメインで外部からもアクセスできるようになる機能です。</li>
</ul></li>
</ul>

  <footer>
  k2nr
</footer>

  </body>
</html>
